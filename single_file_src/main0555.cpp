/**
最少零钱问题 最少硬币问题

 设有n种不同面值的硬币，现要用这些面值的硬币来找开待凑钱数m，可以使用的各种面值的硬币个数不限。
   找出最少需要的硬币个数，并输出其币值。
   数据输入： 由文件input.txt提供输入数据。文件的第1行中有1个正整数n（n<=13），
             表示有n种硬币可选。接下来的一行是每种硬币的面值。由用户输入待找钱数m。
   结果输出： 程序运行结束时，将计算出的所需最少硬币个数和币值输出到文件output.txt中。

动态规划实现
长度为m的数组c[1...m]中存放一系列子结果，即c[i]为要凑的钱数为i时所需的最少硬币数，则c[m]为所求
  当要找的钱数i(1<i<m)与当前所试探的硬币面值k相等时，结果为1，即c[i]=1
  当i大于当前所试探硬币面值k时，若c[i]为0，即还未赋过值，且c[i-k]不为0，即从i元钱中刨去k元后剩下的钱数可以找开，
             则c[i]=c[i-k]+1
        若c[i]不为0，即已赋过值，则c[i]为c[i-k]+1和c[i]中较小的

注：贪心算法可能找不到最优解或者找不到解、
例如：要找开15元，可用硬币为1元，5元，11元，最优解为3个5元，
而用贪心算法得到的解是11元和4个5元。
再如：要找开4元，可用硬币为2元和3元的，最优解为2个2元，而用贪心算法则找不到解
*/
#include <iostream>

using namespace std;

int main()
{
    int i,j;
    int m,n;//m为要凑的钱数，n为不同面值的硬币个数
    cout<<"请输入要凑的钱数:";
    cin>>m;
    int *c=new int[m+1];//动态开辟长度为m+1的数组c[],c[0]不用,其中存放各个子结果

    for(i=0; i<=m; i++) //赋初值为0
    {
        c[i]=0;
    }

    cout<<"请输入不同面值的硬币个数:";
    cin>>n;
    int *a=new int[n];//动态开辟长度为n的数组a[],其中存放n个硬币的面值
    cout<<"请输入"<<n<<"个不同的硬币面值:";

    for(j=0; j<n; j++)
    {
        cin>>a[j];
    }

    for(j=0; j<n; j++) //当要找的钱数i(1<i<m)与当前所试探的硬币面值k相等时，结果为1，即c[i]=1
    {
        c[a[j]]=1;    //即把与硬币面值相等的数组c中的位置赋1
    }

    for(i=1; i<=m; i++) //要凑的钱数为i
        for(j=0; j<n; j++) //试探面值为a[j]的第j+1个硬币
            if(i>a[j])//钱数i大于当前硬币面值时(等于的已处理过;小于的当前找不开,跳过)
            {
                if(c[i]==0 && c[i-a[j]]!=0)
                {
                    c[i]=c[i-a[j]]+1;
                }
                else if(c[i-a[j]]!=0) //第一次没考虑到此时c[i-a[j]]应大于零，感谢csdn的vasile010指正
                {
                    c[i]=c[i-a[j]]+1 < c[i] ? c[i-a[j]]+1 : c[i];
                }
            }

    if(c[m]==0)
    {
        cout<<"找不开!"<<endl;
    }
    else
    {
        cout<<c[m]<<endl;
    }
    return 0;
}
