/**
 * 简单分布式资源调度程序
 * “分布式资源调度程序”是一种运用虚拟环境中可获得的资源来分配和平衡计算容量的工具。应用分布式资源调度程序，用户可以定义虚拟机上资源分配的规则。通过它资源池可以很容易地添加，删除或重组。如果需要，资源池可以在不同的业务单位间隔离。如果有一个或多个虚拟机的工作量大幅度变化，分布式资源调度程序将在物理服务器之间重新分配虚拟机。
 * DRS执行的一个简单的流程为：任意两台不同物理服务器上的虚拟资源总消耗率的差值如果超过了用户定义的阈值，则启动DRS程序，生成虚拟资源迁移方案，按照迁移方案将虚拟资源重新分配到物理服务器上，使所以服务器两两的占用率差值降到阈值以下。
 * 符合阈值的迁移方案会有很多种，我们主要关心最佳迁移方案：
 * 最佳迁移方案※：总消耗率差值最小的迁移方案（迁移后，所有的物理服务器的总消耗率相同，或者两两消耗率差值最小）。
 * •	※ 约束：
 * •	尽量把资源平均分配到各个服务器上。（这里指资源数量，也就是两两服务器上的资源总数差值最小）
 * •	如果存在资源消耗率相同的资源，则优先将编号小的资源迁移到编号小的服务器上；
 * •	如果迁移后，有任意两台服务器的总消耗率相同，则应保证编号小的服务器的资源总数量少；
 * •	如果迁移后，有任意两台服务器的总消耗率相同，并且资源数量也一致，则应保证编号小的服务器上的资源编号升序序列更小。（假设有四个资源标号：1、2、3、4，则升序序列12 < 34；13 < 24；14 < 23）
 * •	如果迁移后，所有的物理服务器的总消耗率总不相同，保证编号大的服务器的总消耗大于编号小的服务器的总消耗。
 * 如下表是一个简单的DRS场景，有两台物理服务器1和2，上面分别消耗1个和3个虚拟资源，用户设置的阈值为10：
 * 服务器编号	消耗率1	消耗率2	消耗率3	总消耗率
 * 1	资源1：30	无	无	30
 * 2	资源2：30	资源3：30	资源4：30	90
 * 表格1 资源消耗场景
 * 在表格1中，服务器1的总消耗率为30，服务器2的总消耗率为90，差值超过了阈值10，所以启动DRS程序，重新将这些虚拟资源分配到两台服务器上，使总消耗率的差值小于10。
 * 如下表，是最佳迁移方案。DRS启动后，迁移方案将资源3迁移到服务器1上，两服务器的总消耗率差值为0，小于阈值10，并且资源被平均到两台服务器上，每个服务器有两个资源：
 * 服务器编号	消耗率1	消耗率2	总消耗率
 * 1	资源1：30	资源2：30	60
 * 2	资源3：30	资源4：30	60
 * 表格2 DRS后资源分配
 * 请根据以上说明，实现一个简单的DRS程序。
 * 程序输入：    阈值
 *                      服务器数量
 * 资源总数
 * 资源（一维数组）的编号、所在服务器编号、消耗率。
 * 程序输出：
 * 1.	如果所有迁移方案中，总会有任意两台服务器的总消耗率差值大于阈值。则认为没有合适的迁移方案，返回False；
 * 2.	如果有合适的迁移方案，则返回True，且输出以下的值：
 * 3.	最佳迁移方案。
 * 输出格式：    资源迁移后所在服务器编号（一维数组，按资源编号升序排序）。
 *
 */
#include "iostream"

struct Resource
{
    int index;					//资源编号
    int serverIndex;			//所在服务器编号
    int consumptionRatios;		//消耗率
};


bool DRS(int threshold, int numOfServer, int numOfResource, Resource* resources)
{
    //在这里实现
    return true;
}


int main()
{
    int threshold = 10;
    int numOfServer = 2;
    Resource req[]={{1,1,30}, {3,2,30}, {2,2,30}, {4,2,30}};
    Resource res[]={{1,1,30},{2,1,30},{3,2,30},{4,2,30}};
    //执行DRS
    bool ret = DRS(threshold, numOfServer, sizeof(req)/sizeof(Resource), req);
    for (int i = 0; i < sizeof(req)/sizeof(Resource); i++)
    {
        std::cout << (req[i].index == res[i].index
                      && req[i].consumptionRatios == res[i].consumptionRatios
                      && req[i].serverIndex == res[i].serverIndex) << std::endl;
    }

}

