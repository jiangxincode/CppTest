/**
 * 小教官
 * 佳佳刚进高中，在军训的时候，由于佳佳吃苦耐劳，很快得到了教官的赏识，成为了“小教官”。在军训结束的那天晚上，佳佳被命令组织同学们进行篝火晚会。一共有n个同学，编号从1到n。一开始，同学们按照1，2，……，n的顺序坐成一圈，而实际上每个人都有两个最希望相邻的同学。如何下命令调整同学的次序，形成新的一个圈，使之符合同学们的意愿，成为摆在佳佳面前的一大难题。
 * 佳佳可向同学们下达命令，每一个命令的形式如下：
 * (b1, b2,... bm -1, bm)
 * 这里m的值是由佳佳决定的，每次命令m的值都可以不同。这个命令的作用是移动编号是b1，b2，…… bm –1，bm的这m个同学的位置。要求b1换到b2的位置上，b2换到b3的位置上，……，要求bm换到b1的位置上。
 * 执行每个命令都需要一些代价。我们假定如果一个命令要移动m个人的位置，那么这个命令的代价就是m。我们需要佳佳用最少的总代价实现同学们的意愿，你能帮助佳佳吗?
 * 对于30%的数据，n <= 1000；
 * 对于全部的数据，n <= 50000。
 *
 * 输入
 * 输入的第一行是一个整数n（3 <= n <= 50000），表示一共有n个同学。其后n行每行包括两个不同的正整数，以一个空格隔开，分别表示编号是1的同学最希望相邻的两个同学的编号，编号是2的同学最希望相邻的两个同学的编号，……，编号是n的同学最希望相邻的两个同学的编号。
 * 输出
 * 输出包括一行，这一行只包含一个整数，为最小的总代价。如果无论怎么调整都不能符合每个同学的愿望，则输出-1。
 * 样例输入
 * 4
 * 3 4
 * 4 3
 * 1 2
 * 1 2
 * 样例输出
 * 2
 *
 *
 * 接口描述
 * int Findfriend(unsigned int n, unsigned int* friend_seat)
 *
 * 输入参数：
 * unsigned int n：所有同学的人数
 * unsigned int* friend_seat：指向二维数组的指针，每一行存放每人喜欢的人的座位号。其中，第0列存放一个喜欢的人的座位号，第 1列存放另一个喜欢的人的座位号
 *
 * 输出参数:无
 * 返回值：
 * int 型。返回最小代价
 *
 */
#include "iostream"
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>


/*
功能:通过移动使同学们和喜欢的人邻座

输入参数：
	 	unsigned int n：所有同学的人数
		unsigned int* friend_seat：指向二维数组的指针，每一行存放每人喜欢的人的座位号。其中，第0列存放一个喜欢的人的座位号，第 1列存放另一个喜欢的人的座位号

输出参数:无
返回值：
		int 型。返回最小代价

*/



int Findfriend(unsigned int n, unsigned int* friend_seat)
{
    return 0;
}

int main()
{
    unsigned int stu_num=4;
    unsigned int fri_seat[4][2]={{3,4},{4,3},{1,2},{1,2}};

    int aResult=Findfriend(stu_num,&fri_seat[0][0]);

    std::cout << (aResult==2) << std::endl;


}



