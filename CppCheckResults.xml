<?xml version="1.0" encoding="UTF-8" ?>
<results>
    <error file="LinkedSet.h" line="15" id="noCopyConstructor" severity="style" msg="&apos;class LinkedSet&lt;T&gt;&apos; does not have a copy constructor which is recommended since the class contains a pointer to allocated memory." />
    <error file="binary_tree.h" line="14" id="uninitMemberVar" severity="style" msg="Member variable &apos;binary_node::parent&apos; is not initialized in the constructor." />
    <error file="binary_tree.h" line="15" id="uninitMemberVar" severity="style" msg="Member variable &apos;binary_node::parent&apos; is not initialized in the constructor." />
    <error file="binary_tree.cpp" line="36" id="StlMissingComparison" severity="style" msg="The iterator incrementing is suspicious - it is incremented at line 64 and then at line 36. The loop might unintentionally skip an element in the container. There is no comparison between these increments to prevent that the iterator is incremented beyond the end." />
    <error file="circ_list.h" line="12" id="noCopyConstructor" severity="style" msg="&apos;class CircList&lt;T&gt;&apos; does not have a copy constructor which is recommended since the class contains a pointer to allocated memory." />
    <error file="hash.h" line="37" id="syntaxError" severity="error" msg="Invalid number of character ({) when these macros are defined: &apos;&apos;." />
    <error file="heap.h" line="3" id="noCopyConstructor" severity="style" msg="&apos;class heap&apos; does not have a copy constructor which is recommended since the class contains a pointer to allocated memory." />
    <error file="linear_list.h" line="24" id="operatorEq" severity="style" msg='The LinearList&lt;T&gt;::operator= does not conform to standard C/C++ behaviour. To conform to standard C/C++ behaviour, return a reference to self (such as: &apos;LinearList&lt;T&gt; &amp;LinearList&lt;T&gt;::operator=(..) { .. return *this; }&apos;. For safety reasons it might be better to not fix this message. If you think that safety is always more important than conformance then please ignore/suppress this message. For more details about this topic, see the book &quot;Effective C++&quot; by Scott Meyers.' />
    <error file="static_list.h" line="13" id="noConstructor" severity="style" msg="The class &apos;StaticList&lt;T&gt;&apos; does not have a constructor although it has private member variables. Member variables of builtin types are left uninitialized when the class is instantiated. That may cause bugs or undefined behavior." />
    <error file="seq_list.h" line="84" id="uninitMemberVar" severity="style" msg="Member variable &apos;SeqList&lt;T&gt;::maxSize&apos; is not initialized in the constructor." />
    <error file="linked_list.h" line="15" id="uninitMemberVar" severity="style" msg="Member variable &apos;LinkNode&lt;int&gt;::data&apos; is not initialized in the constructor." />
    <error file="seq_list.h" line="63" id="operatorEq" severity="style" msg='The SeqList&lt;T&gt;::operator= does not conform to standard C/C++ behaviour. To conform to standard C/C++ behaviour, return a reference to self (such as: &apos;SeqList&lt;T&gt; &amp;SeqList&lt;T&gt;::operator=(..) { .. return *this; }&apos;. For safety reasons it might be better to not fix this message. If you think that safety is always more important than conformance then please ignore/suppress this message. For more details about this topic, see the book &quot;Effective C++&quot; by Scott Meyers.' />
    <error file="linked_list.h" line="28" id="noCopyConstructor" severity="style" msg="&apos;class List&lt;int&gt;&apos; does not have a copy constructor which is recommended since the class contains a pointer to allocated memory." />
    <error file="seq_list.h" line="71" id="constStatement" severity="style" msg="Redundant code: Found a statement that begins with numeric constant." />
    <error file="seq_list.h" line="86" id="constStatement" severity="style" msg="Redundant code: Found a statement that begins with numeric constant." />
    <error file="main0503.cpp" line="44" id="redundantAssignment" severity="style" msg="Variable &apos;ch&apos; is reassigned a value before the old one has been used." />
    <error file="main0503.cpp" line="76" id="unreadVariable" severity="style" msg="Variable &apos;ch&apos; is assigned a value that is never used." />
    <error file="main0503.cpp" line="77" id="obsoleteFunctionsgets" severity="style" msg="The obsolete function &apos;gets&apos; is called. With &apos;gets&apos; you&apos;ll get a buffer overrun if the input data exceeds the size of the buffer. It is recommended to use the function &apos;fgets&apos; instead." />
    <error file="main0506.cpp" line="32" id="invalidscanf" severity="style" msg='scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem:    %s =&gt; %20sSample program that can crash:#include &lt;stdio.h&gt;int main(){    char c[5];    scanf(&quot;%s&quot;, c);    return 0;}Typing in 5 or more characters may make the program crash. The correct usage here is &apos;scanf(&quot;%4s&quot;, c);&apos;, as the maximum field width does not include the terminating null byte.Source: http://linux.die.net/man/3/scanfSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c' />
    <error file="main0507.cpp" line="24" id="invalidscanf" severity="style" msg='scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem:    %s =&gt; %20sSample program that can crash:#include &lt;stdio.h&gt;int main(){    char c[5];    scanf(&quot;%s&quot;, c);    return 0;}Typing in 5 or more characters may make the program crash. The correct usage here is &apos;scanf(&quot;%4s&quot;, c);&apos;, as the maximum field width does not include the terminating null byte.Source: http://linux.die.net/man/3/scanfSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c' />
    <error file="main0511.cpp" line="31" id="variableScope" severity="style" msg="The scope of the variable &apos;count&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main0511.cpp" line="34" id="invalidscanf" severity="style" msg='scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem:    %s =&gt; %20sSample program that can crash:#include &lt;stdio.h&gt;int main(){    char c[5];    scanf(&quot;%s&quot;, c);    return 0;}Typing in 5 or more characters may make the program crash. The correct usage here is &apos;scanf(&quot;%4s&quot;, c);&apos;, as the maximum field width does not include the terminating null byte.Source: http://linux.die.net/man/3/scanfSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c' />
    <error file="main0511.cpp" line="59" id="invalidscanf" severity="style" msg='scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem:    %s =&gt; %20sSample program that can crash:#include &lt;stdio.h&gt;int main(){    char c[5];    scanf(&quot;%s&quot;, c);    return 0;}Typing in 5 or more characters may make the program crash. The correct usage here is &apos;scanf(&quot;%4s&quot;, c);&apos;, as the maximum field width does not include the terminating null byte.Source: http://linux.die.net/man/3/scanfSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c' />
    <error file="main0511.cpp" line="69" id="memleak" severity="error" msg="Memory leak: an" />
    <error file="main0513.cpp" line="258" id="obsoleteFunctionsgets" severity="style" msg="The obsolete function &apos;gets&apos; is called. With &apos;gets&apos; you&apos;ll get a buffer overrun if the input data exceeds the size of the buffer. It is recommended to use the function &apos;fgets&apos; instead." />
    <error file="main0517.cpp" line="195" id="invalidscanf" severity="style" msg='scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem:    %s =&gt; %20sSample program that can crash:#include &lt;stdio.h&gt;int main(){    char c[5];    scanf(&quot;%s&quot;, c);    return 0;}Typing in 5 or more characters may make the program crash. The correct usage here is &apos;scanf(&quot;%4s&quot;, c);&apos;, as the maximum field width does not include the terminating null byte.Source: http://linux.die.net/man/3/scanfSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c' />
    <error file="main0520.cpp" line="57" id="unreadVariable" severity="style" msg="Variable &apos;temp&apos; is assigned a value that is never used." />
    <error file="main0522.cpp" line="22" id="unusedVariable" severity="style" msg="Unused variable: result" />
    <error file="main0524.cpp" line="55" id="StlMissingComparison" severity="style" msg="The iterator incrementing is suspicious - it is incremented at line 64 and then at line 55. The loop might unintentionally skip an element in the container. There is no comparison between these increments to prevent that the iterator is incremented beyond the end." />
    <error file="main0525.cpp" line="10" id="unusedStructMember" severity="style" msg="struct or union member &apos;test::i_var&apos; is never used." />
    <error file="main0525.cpp" line="11" id="unusedStructMember" severity="style" msg="struct or union member &apos;test::c_var&apos; is never used." />
    <error file="main0526.cpp" line="22" id="uninitMemberVar" severity="style" msg="Member variable &apos;BinaryTree&lt;char&gt;::RefValue&apos; is not initialized in the constructor." />
    <error file="main0526.cpp" line="14" id="uninitMemberVar" severity="style" msg="Member variable &apos;BinTreeNode&lt;char&gt;::data&apos; is not initialized in the constructor." />
    <error file="main0529.cpp" line="92" id="variableScope" severity="style" msg="The scope of the variable &apos;mid&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main0529.cpp" line="160" id="variableScope" severity="style" msg="The scope of the variable &apos;mid&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main0532.cpp" line="30" id="unusedStructMember" severity="style" msg="struct or union member &apos;topic_info_t::topic_id&apos; is never used." />
    <error file="main0534.cpp" line="36" id="memleak" severity="error" msg="Memory leak: arr" />
    <error file="main0535.cpp" line="67" id="memleak" severity="error" msg="Memory leak: maxArr" />
    <error file="main0539.cpp" line="80" id="invalidscanf" severity="style" msg='scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem:    %s =&gt; %20sSample program that can crash:#include &lt;stdio.h&gt;int main(){    char c[5];    scanf(&quot;%s&quot;, c);    return 0;}Typing in 5 or more characters may make the program crash. The correct usage here is &apos;scanf(&quot;%4s&quot;, c);&apos;, as the maximum field width does not include the terminating null byte.Source: http://linux.die.net/man/3/scanfSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c' />
    <error file="main0539.cpp" line="46" id="memleak" severity="error" msg="Memory leak: result" />
    <error file="main0542.cpp" line="128" id="leakNoVarFunctionCall" severity="error" msg="Allocation with LCS, printf doesn&apos;t release it." />
    <error file="main0542.cpp" line="118" id="memleak" severity="error" msg="Memory leak: c" />
    <error file="main0542.cpp" line="124" id="obsoleteFunctionsgets" severity="style" msg="The obsolete function &apos;gets&apos; is called. With &apos;gets&apos; you&apos;ll get a buffer overrun if the input data exceeds the size of the buffer. It is recommended to use the function &apos;fgets&apos; instead." />
    <error file="main0542.cpp" line="126" id="obsoleteFunctionsgets" severity="style" msg="The obsolete function &apos;gets&apos; is called. With &apos;gets&apos; you&apos;ll get a buffer overrun if the input data exceeds the size of the buffer. It is recommended to use the function &apos;fgets&apos; instead." />
    <error file="main0544.cpp" line="17" id="variableScope" severity="style" msg="The scope of the variable &apos;flag&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main1000.cpp" line="55" id="useInitializationList" severity="style" msg="When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don&apos;t explicitly write them to the initialization list. You could avoid assigning &apos;int_set&apos; a value by passing the value to the constructor in the initialization list." />
    <error file="main1590.cpp" line="56" id="unreadVariable" severity="style" msg="Variable &apos;alpha_1&apos; is assigned a value that is never used." />
    <error file="main1590.cpp" line="57" id="unreadVariable" severity="style" msg="Variable &apos;alpha_2&apos; is assigned a value that is never used." />
    <error file="main1730.cpp" line="234" id="variableScope" severity="style" msg="The scope of the variable &apos;flag&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main1730.cpp" line="118" id="uninitMemberVar" severity="style" msg="Member variable &apos;Queen::q&apos; is not initialized in the constructor." />
    <error file="main1730.cpp" line="325" id="stlIfFind" severity="style" msg="Suspicious condition. The result of find() is an iterator, but it is not properly checked." />
    <error file="main1730.cpp" line="353" id="stlIfFind" severity="style" msg="Suspicious condition. The result of find() is an iterator, but it is not properly checked." />
    <error file="main1740.cpp" line="21" id="clarifyCondition" severity="style" msg="Suspicious condition (assignment + comparison); Clarify expression with parentheses." />
    <error file="main1740.cpp" line="36" id="clarifyCondition" severity="style" msg="Suspicious condition (assignment + comparison); Clarify expression with parentheses." />
    <error file="main1740.cpp" line="16" id="variableScope" severity="style" msg="The scope of the variable &apos;min&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main1740.cpp" line="16" id="variableScope" severity="style" msg="The scope of the variable &apos;max&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main1740.cpp" line="459" id="variableScope" severity="style" msg="The scope of the variable &apos;j&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main1740.cpp" line="459" id="variableScope" severity="style" msg="The scope of the variable &apos;max&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main1740.cpp" line="21" id="checkCastIntToCharAndBack" severity="style" msg='When saving getchar() return value in char variable there is loss of precision.  When getchar() returns EOF this value is truncated. Comparing the char variable with EOF can have unexpected results. For instance a loop &quot;while (EOF != (c = getchar());&quot; loops forever on some compilers/platforms and on other compilers/platforms it will stop when the file contains a matching character.' />
    <error file="main1740.cpp" line="36" id="checkCastIntToCharAndBack" severity="style" msg='When saving getchar() return value in char variable there is loss of precision.  When getchar() returns EOF this value is truncated. Comparing the char variable with EOF can have unexpected results. For instance a loop &quot;while (EOF != (c = getchar());&quot; loops forever on some compilers/platforms and on other compilers/platforms it will stop when the file contains a matching character.' />
    <error file="LinkedSet.h" line="10" id="uninitMemberVar" severity="style" msg="Member variable &apos;SetNode&lt;int&gt;::data&apos; is not initialized in the constructor." />
    <error file="LinkedSet.h" line="15" id="noCopyConstructor" severity="style" msg="&apos;class LinkedSet&lt;int&gt;&apos; does not have a copy constructor which is recommended since the class contains a pointer to allocated memory." />
    <error file="main2001.cpp" line="88" id="variableScope" severity="style" msg="The scope of the variable &apos;root&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main2001.cpp" line="163" id="variableScope" severity="style" msg="The scope of the variable &apos;tmp&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main2001.cpp" line="91" id="invalidscanf" severity="style" msg='scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem:    %s =&gt; %20sSample program that can crash:#include &lt;stdio.h&gt;int main(){    char c[5];    scanf(&quot;%s&quot;, c);    return 0;}Typing in 5 or more characters may make the program crash. The correct usage here is &apos;scanf(&quot;%4s&quot;, c);&apos;, as the maximum field width does not include the terminating null byte.Source: http://linux.die.net/man/3/scanfSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c' />
    <error file="main2001.cpp" line="97" id="invalidscanf" severity="style" msg='scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem:    %s =&gt; %20sSample program that can crash:#include &lt;stdio.h&gt;int main(){    char c[5];    scanf(&quot;%s&quot;, c);    return 0;}Typing in 5 or more characters may make the program crash. The correct usage here is &apos;scanf(&quot;%4s&quot;, c);&apos;, as the maximum field width does not include the terminating null byte.Source: http://linux.die.net/man/3/scanfSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c' />
    <error file="main2001.cpp" line="103" id="invalidscanf" severity="style" msg='scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem:    %s =&gt; %20sSample program that can crash:#include &lt;stdio.h&gt;int main(){    char c[5];    scanf(&quot;%s&quot;, c);    return 0;}Typing in 5 or more characters may make the program crash. The correct usage here is &apos;scanf(&quot;%4s&quot;, c);&apos;, as the maximum field width does not include the terminating null byte.Source: http://linux.die.net/man/3/scanfSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c' />
    <error file="main2500.cpp" line="139" id="variableScope" severity="style" msg="The scope of the variable &apos;p1&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main2500.cpp" line="209" id="variableScope" severity="style" msg="The scope of the variable &apos;p2&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main2500.cpp" line="77" id="invalidscanf" severity="style" msg='scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem:    %s =&gt; %20sSample program that can crash:#include &lt;stdio.h&gt;int main(){    char c[5];    scanf(&quot;%s&quot;, c);    return 0;}Typing in 5 or more characters may make the program crash. The correct usage here is &apos;scanf(&quot;%4s&quot;, c);&apos;, as the maximum field width does not include the terminating null byte.Source: http://linux.die.net/man/3/scanfSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c' />
    <error file="main2500.cpp" line="109" id="invalidscanf" severity="style" msg='scanf without field width limits can crash with huge input data. Add a field width specifier to fix this problem:    %s =&gt; %20sSample program that can crash:#include &lt;stdio.h&gt;int main(){    char c[5];    scanf(&quot;%s&quot;, c);    return 0;}Typing in 5 or more characters may make the program crash. The correct usage here is &apos;scanf(&quot;%4s&quot;, c);&apos;, as the maximum field width does not include the terminating null byte.Source: http://linux.die.net/man/3/scanfSource: http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/libkern/stdio/scanf.c' />
    <error file="main2572.cpp" line="17" id="clarifyCondition" severity="style" msg="Suspicious condition (assignment + comparison); Clarify expression with parentheses." />
    <error file="main2572.cpp" line="32" id="clarifyCondition" severity="style" msg="Suspicious condition (assignment + comparison); Clarify expression with parentheses." />
    <error file="main2572.cpp" line="12" id="variableScope" severity="style" msg="The scope of the variable &apos;min&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main2572.cpp" line="12" id="variableScope" severity="style" msg="The scope of the variable &apos;max&apos; can be reduced. Warning: Be careful when fixing this message, especially when there are inner loops. Here is an example where cppcheck will write that the scope for &apos;i&apos; can be reduced:void f(int x){    int i = 0;    if (x) {        // it&apos;s safe to move &apos;int i = 0;&apos; here        for (int n = 0; n &lt; 10; ++n) {            // it is possible but not safe to move &apos;int i = 0;&apos; here            do_something(&amp;i);        }    }}When you see this message it is always safe to reduce the variable scope 1 level." />
    <error file="main2572.cpp" line="17" id="checkCastIntToCharAndBack" severity="style" msg='When saving getchar() return value in char variable there is loss of precision.  When getchar() returns EOF this value is truncated. Comparing the char variable with EOF can have unexpected results. For instance a loop &quot;while (EOF != (c = getchar());&quot; loops forever on some compilers/platforms and on other compilers/platforms it will stop when the file contains a matching character.' />
    <error file="main2572.cpp" line="32" id="checkCastIntToCharAndBack" severity="style" msg='When saving getchar() return value in char variable there is loss of precision.  When getchar() returns EOF this value is truncated. Comparing the char variable with EOF can have unexpected results. For instance a loop &quot;while (EOF != (c = getchar());&quot; loops forever on some compilers/platforms and on other compilers/platforms it will stop when the file contains a matching character.' />
</results>
