/*======================================================
 * 函数名：hamming
 * 功能描述：哈明方法求常微分方程组的初值问题
 * 输入参数：*y（ 指向函数初值以及函数返回值的指针n*(m+1)）
 *          n（方程组个数），f（斜率的计算）
 *          h（步长），m（步数），a（区间起点）
 * 返回值：0（失败），1（成功）
=========================================================*/
#include<stdlib.h>
#include<stdio.h>
#include<math.h>
#include "../utility.h"

int hamming(double *y,int n,double (*f)(),double h,int m,double a)
{
    double *c,*f1,*f2,*f3,*f4,*temp,*ptemp,*p,x;
    int k=3,i;
    c=(double*)malloc(sizeof(double)*n);
    p=(double*)malloc(sizeof(double)*n);      /* 微分方程斜率*/
    f1=(double*)malloc(sizeof(double)*n);
    f2=(double*)malloc(sizeof(double)*n);
    f3=(double*)malloc(sizeof(double)*n);
    f4=(double*)malloc(sizeof(double)*n);
    ptemp=(double*)malloc(sizeof(double)*n);

    if(c==NULL||p==NULL||f2==NULL||f3==NULL||f4==NULL||f1==NULL||ptemp==NULL)
    {
        printf("memory alloc failed.\n");
        return(0);
    }

    rungekuttainvh(y,n,f,h,3,a);              /* 用龙格-库塔法计算前4个初值*/
    {
        x=a+k*h;
        f(&y[(k-2)*n],f1,x-2*h);              /* x(k-2)处的f*/
        f(&y[(k-1)*n],f2,x-h);                /* x(k-1)处的f*/
        f(&y[k*n],f3,x);                      /* xk处的f*/

        for(i=0; i<n; i++)                    /* 预报p*/
        {
            p[i]=y[(k-3)*n+i]+4.0*h/3.0*(2.0*f3[i]-f2[i]+2.0*f1[i]);
        }

        f(p,f4,x+h);                          /* 预报x(k+1)处的f*/

        for(i=0; i<n; i++)
        {
            /* 预报c*/
            c[i]=1.0/8.0*(9.0*y[k*n+i]-y[(k-2)*n+i]+3.0*h*(f4[i]+2.0*f3[i]-f2[i]));
            y[(k+1)*n+i]=c[i]-9.0/121.0*(c[i]-p[i]);              /* 计算最终结果*/
        }

        k++;
    }

    while(k<m)                                /* 循环*/
    {
        x=a+k*h;
        temp=f1;
        f1=f2;
        f2=f3;
        f3=temp;
        f(&y[k*n],f3,x);

        for(i=0; i<n; i++)
        {
            ptemp[i]=y[(k-3)*n+i]+4.0*h/3.0*(2.0*f3[i]-f2[i]+2.0*f1[i]);  /* 预报*/
            p[i]=ptemp[i]+112.0/121.0*(c[i]-p[i]);                        /* 预报*/
        }

        f(p,f4,x+h);                        					   /* x(k+1)处的f*/

        for(i=0; i<n; i++)
        {
            c[i]=1.0/8.0*(9.0*y[k*n+i]-y[(k-2)*n+i]+3.0*h*(f4[i]+2.0*f3[i]-f2[i]));
            y[(k+1)*n+i]=c[i]-9.0/121.0*(c[i]-p[i]);
        }

        k++;
    }

    free(p);
    free(f2);
    free(f3);
    free(f4);
    free(f1);
    free(ptemp);
    free(c);
    return (1);
}


