#include "../utility.h"

/**
 * 函数名：r_mdet
 * 功能描述：求实矩阵的行列式值
 * 输入参数：mat(输入的矩阵) n(矩阵阶数) eps(精度)
 * 返回值：矩阵的行列式值
 */
double r_mdet(double *mat, int n, double eps)
{
    int i,j,k,is,js,l,v;
    double det, flag, tmp, pivot;
    double *cpmat;

    if(mat == NULL)                            /* 检查输入的指针是否为空*/
    {
        printf("matrix pointer is NULL.\n");
        return(0.0);
    }

    cpmat = (double*)malloc(n*n*sizeof(double));  /* 将输入矩阵的内容拷贝一份，以免破坏*/

    for(i=0; i<n*n; i++)
    {
        cpmat[i] = mat[i];
    }

    det = 1.0;                                 /* 设置行列式值初置*/
    flag = 1.0;                                /* 这个变量原来记录行列式值的符号*/

    for(k=0; k<n-1; k++)           /* 最多进行n-1次消去*/
    {
        pivot = 0.0;                             /* 选择主元*/

        for(i=k; i<n; i++)
            for(j=k; j<n; j++)
            {
                tmp = fabs(cpmat[i*n+j]);

                if(tmp > pivot)
                {
                    pivot = tmp;
                    is = i;
                    js = j;
                }
            }

        if(pivot < eps)                          /* 如果找到的主元小于eps，则认为是0。*/
        {
            det = 0.0;                             /*此时行列式值也是0。*/
            return(det);
        }

        if(is != k)                              /* 判断是否需要行交换*/
        {
            flag = -flag;                          /* 行交换一次，行列式值变号*/

            for(j=k; j<n; j++)                     /* 进行行交换*/
            {
                l = k*n + j;
                v = is*n + j;
                tmp = cpmat[l];
                cpmat[l] = cpmat[v];
                cpmat[v] = tmp;
            }
        }

        if(js != k)                              /* 判断是否需要列交换*/
        {
            flag = -flag;                          /* 列交换一次，行列式值变号*/

            for(i=k; i<n; i++)                     /* 进行列交换*/
            {
                l = i*n + k;
                v = i*n + js;
                tmp = cpmat[l];
                cpmat[l] = cpmat[v];
                cpmat[v] = tmp;
            }
        }

        for(i=k+1; i<n; i++)                    /* 进行消去*/
        {
            tmp = cpmat[i*n+k]/cpmat[k*n+k];          /* 记录下此值，减少除法的次数*/

            for(j=k+1; j<n; j++)                  /* 消去*/
            {
                cpmat[i*n+j] -= tmp*cpmat[k*n+j];
            }
        }

        det = det*cpmat[k*n+k];           /*更新det的值*/
    }

    det = flag*det*cpmat[k*n+k];        /* 最终更新det的值*/
    free(cpmat);
    return(det);
}
