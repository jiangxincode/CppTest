#include "../utility.h"

/**
 * 函 数 名：hadma1 (x,n,y)
 * 功能描述：哈达玛变换
 * 输入参数：x（变换初始值），n（系数个数）、y（变换后序列）
 * 返 回 值：整型数字。计算成功则返回1，否则返回0
 */
static int hadma1(double *x,int n,double *y);    /* 因为要递归调用，所以先声明*/
int hadma(double *y,int n,double *x)
{
    int i,j,k,nn;
    double t;
    k = log(n-0.5)/log(2.0)+1;                  /* 求出k，使2^k>=n>2^(k-1) */
    nn = 1;			                    /* 判断n是否是2的整数幂，不是的话退出程序*/

    for(i=0; i<k; i++)
    {
        nn = nn<<1;
    }

    if(nn != n)
    {
        printf("n should be 2^k.\n");
        return 0;
    }

    j = hadma1(y,n,x);		                       /* 调用子函数求解求和符号中的部分*/

    if(j)
    {
        t = 1.0/sqrt(n);

        for(i=0; i<n; i++)		                       /* 将子函数返回的结果除以n^0.5*/
        {
            x[i] *= t;
        }
    }

    return(j);
}
static int hadma1(x,n,y)
int n;
double *x,*y;
{
    int i,j,k;
    double t;

    if(n==1)
    {
        /* 当序列长度为1时，沃尔什变换是它本身*/
        y[0] = x[0];
        return 1;
    }

    k = n>>1;		                     /* k是n的一半，即两个小规模问题需要分配空间大小*/
    i = hadma1(x,k,y);                 /* 递归调用此函数，变换前一半*/
    j = hadma1(x+k,k,y+k); 	             /* 递归调用此函数，变换后一半*/

    if(i && j)                                /* 将得到的两部分序列综合起来*/
    {
        for(i=0; i<k; i++)
        {
            /* 一加一减，完成了序列的综合*/
            t = y[i+k];
            y[i+k] = y[i] - t;
            y[i] = y[i] + t;
        }
    }

    return 1;
}
