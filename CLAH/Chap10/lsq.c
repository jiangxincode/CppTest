#include "../utility.h"

/**
 * 函数名：lsq
 * 功能描述：最小二乘拟合
 * 输入参数：x 指向存放n个结点的数据的数组的指针
 *           y 指向存放n个结点的函数值的数组的指针
 *           n 结点的个数
 *           p 指向存放pp个拟合多项式系数的数组的指针
 *           pp 拟合多项式次数+1
 *           s 指向数组的指针，存放4个数据，返回的依次是： 误差的平方和,
 *             误差的绝对值的最大值、误差的绝对值之和,x0的平均值
 * 返回值：  整型。若拟合成功则返回1,否则返回0
 */
int lsq(double *x,double *y,int n,double *p,int pp,double *s)
{
    int i,j,k;
    double a,b,d0,d1,d2,c,t;
    double *q0,*q1,*q2,*x0;                              /* 存放正交多项式Q的系数*/
    double *q0y,*q1y,*q2y;                          /* 存放正交多项式Q在各点上的值*/

    if(!(x && y && p && s))                           /* 检测输入指针是否为空*/
    {
        printf("Pointer is Null\n");
        return(0);
    }

    q0 = (double*)malloc(pp*sizeof(double));          /* 分配空间并检测是否成功*/
    q1 = (double*)malloc(pp*sizeof(double));
    q2 = (double*)malloc(pp*sizeof(double));

    if(!(q0 && q1 && q2))
    {
        free(q0);
        free(q1);
        free(q2);
        printf("Memory alloc Failed\n");
        return(0);
    }

    x0 = (double*)malloc(n*sizeof(double));
    q0y = (double*)malloc(n*sizeof(double));          /* 分配空间并检测是否成功*/
    q1y = (double*)malloc(n*sizeof(double));
    q2y = (double*)malloc(n*sizeof(double));

    if(!(x && q0y && q1y && q2y))
    {
        free(x);
        free(q0y);
        free(q1y);
        free(q2y);
        printf("Memory alloc Failed\n");
        return(0);
    }

    t=0.0;

    for(k=0; k<n; k++)
    {
        t = t+x[k]/n;
    }

    s[3] = t;

    for(k=0; k<n; k++)
    {
        x0[k] = x[k]-t;
    }

    for(i=0; i<pp; i++)                               /* 设初值*/
    {
        q0[i] = 0.0;
        q1[i] = 0.0;
        q2[i] = 0.0;
        p[i] = 0.0;
    }

    for(k=0; k<n; k++)
    {
        q0y[k] = 1.0;
    }

    q0[0] = 1;                                        /* Q0的系数*/
    c = 0.0;
    d0 = n;

    for(k=0; k<n; k++)                                /* 计算c0*/
    {
        c = c+y[k]/d0;
    }

    p[0] = c;                                      /* 拟合多项式P(x)的系数*/
    q1[0] = 0.0;
    q1[1] = 1.0;                                      /* Q1的系数*/
    d1 = 0.0;
    c = 0.0;

    for(k=0; k<n; k++)                                /* 计算d1和c1*/
    {
        t =  x0[k];
        q1y[k] = t;                                     /* Q1在数据点上的值*/
        d1 = d1+t*t;
        c = c+t*y[k];
    }

    c = c/d1;
    p[0] = p[0]+c*q1[0];                             /* 更新拟合多项式*/
    p[1] = p[1]+c*q1[1];

    for(i=2; i<pp; i++)
    {
        a = 0.0;

        for(k=0; k<n; k++)
        {
            a = a+x0[k]*q1y[k]*q1y[k];
        }

        a = a/d1;                                      /* alphai*/
        b = d1/d0;                                     /* beta*/
        d2 = 0;
        c = 0;

        for(k=0; k<n; k++)                             /* 计算Qi的函数值和c,d*/
        {
            t = (x0[k]-a)*q1y[k] - b*q0y[k];
            q2y[k] = t;
            d2 = d2+t*t;
            c = c+t*y[k];
        }

        c = c/d2;
        q2[0] = -a*q1[0]-b*q0[0];                      /* 计算Qi的系数*/
        p[0] = p[0] + c*q2[0];                         /* 更新P(x)的系数*/

        for(j=1; j<=i; j++)
        {
            q2[j] = q1[j-1]-a*q1[j]-b*q0[j];
            p[j] = p[j]+c*q2[j];
        }

        d0 = d1;
        d1 = d2;                              /* 循环使用变量*/

        for(k=0; k<n; k++)                             /* 循环使用数组*/
        {
            q0y[k] = q1y[k];
            q1y[k] = q2y[k];
        }

        for(j=0; j<=i; j++)
        {
            q0[j] = q1[j];
            q1[j] = q2[j];
        }
    }

    s[0]=0.0;
    s[1]=0.0;
    s[2]=0.0;

    for(i=0; i<n; i++)
    {
        t = p[pp-1];

        for(k=pp-2; k>=0; k--)
        {
            t=p[k]+t*x0[i];
        }

        t = t-y[i];

        if(fabs(t)>s[2])
        {
            s[2]=fabs(t);
        }

        s[0] = s[0]+t*t;
        s[1] = s[1]+fabs(t);
    }

    free(q0);
    free(q1);
    free(q2);                  /* 释放空间*/
    free(x);
    free(q0y);
    free(q1y);
    free(q2y);
    return(1);
}
