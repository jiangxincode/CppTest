/*======================================================
 * 函数名：leg1
 * 功能描述：勒让德-高斯求积法
 * 输入参数：a 积分下限，b 积分上限,
 *           n0 初始划分数
 *           eps 精度要求
 *           h0 最小步长
 *           f 指向被积函数的指针
 * 返回值：  积分近似值
 */
#include <math.h>
static double leg1(a,b,n0,eps,h0,f)
double a,b,eps,h0;
int n0;
double(*f)();
{
    int n,i,j;
    double z,z2,h,d,x;
    static double t[5] = {-0.906179845938664, -0.538469310105683,0.0,
                          0.538469310105683, 0.906179845938664
                         }; /* 5阶勒让德多项式的零点*/
    static double c[5] = {0.236926885056189,0.478628670499366,
                          0.568888888888888,0.478628670499366,
                          0.236926885056189
                         };    /* 使用5阶勒让德多项式时的参数*/
    n = n0;                            /* 初始的划分数*/
    h = (b-a)/n;                       /* 求得初始步长*/
    z = 0.0;                           /* 计算初始的积分值*/

    for(i=0; i<n; i++)
    {
        x = a+i*h+h/2.0;

        for(j=0; j<5; j++)
        {
            z = z+c[j]*(*f)(h/2.0*t[j]+x);
        }
    }

    z = z*h/2.0;

    do
    {
        n = 2*n;                          /* 更新划分数*/
        h = h/2.0;                        /* 更新步长*/
        z2 = 0.0;                         /* 计算新的积分值*/

        for(i=0; i<n; i++)
        {
            x = a+i*h+h/2.0;

            for(j=0; j<5; j++)
            {
                z2 = z2+c[j]*(*f)(h/2.0*t[j]+x);
            }
        }

        z2 = z2*h/2.0;                   /* 尽量减少乘法次数*/
        d = fabs(z2-z);                  /* 计算两次积分值的差*/
        z = z2;                          /* 更新积分值*/
    }
    while((d>eps)&&(h>h0));

    return(z);
}
