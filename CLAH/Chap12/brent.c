#include <stdio.h>
#include <math.h>
#define G2 0.38196601

/**
 * 函数名：brent
 * 功能描述：Brent算法法求极值
 * 输入参数：a 初始区间的左端点
 *           b 初始区间的中间点
 *           c 初始区间的右端点
 *           f 函数指针
 *           xopt 指针，指向极值点的坐标
 *           eps 精度限度
 *           itmax 最大迭代次数
 * 返回值：  函数的极小值
 */
double brent(double a, double b, double c, double(*f)(double), double *xopt, double eps, int itmax)
{
    int it;
    double xm,x,u,w,v,fx,fu,fw,fv,eps1,eps2,d0,d;
    double p,q,r;                                      /* 用于抛物线插值*/
    x=w=v=b;
    fx=fw=fv=(*f)(b);
    d0 = 0.0;

    for(it=0; it<itmax; it++)
    {
        xm = (a+c)*0.5;
        eps1 = eps*fabs(x)+1.0e-10;
        eps2 = 2.0*eps1;

        if((c-a)*0.5 < (eps2-fabs(x-xm)))               /* 迭代收敛准则*/
        {
            *xopt = x;
            return(fx);
        }

        if(fabs(d0) <= eps1)                            /* 上次变化太小，用黄金分割法*/
        {
            d0 = (x>xm)?a-x:c-x;
            d = G2*d0;
        }
        else
        {
            r = (x-w)*(fx-fv);                         /* 抛物线插值*/
            q = (x-v)*(fx-fw);
            p = (x-v)*q-(x-w)*r;
            q = 2.0*(q-r);

            if(q>0.0)
            {
                p = -p;
            }

            q = fabs(q);                                /* 新近似点不满足两个条件*/

            if(fabs(r)>fabs(0.5*q*d0) || p>=q*(c-x) || p<=q*(a-x))
            {
                d0 = (x>xm)?a-x:c-x;                    /* 用黄金分割法*/
                d = G2*d0;
            }
            else
            {
                d0 = d;
                d = p/q;
                u = x+d;

                if(u-a<eps2 || c-u<eps2)                 /* 抛物线插值结果与端点过于接近，不接受*/
                {
                    d = fabs(eps1)*((xm-x>0)?1.0:-1.0);
                }
            }
        }

        if(fabs(d)>=eps1)
        {
            u = x+d;
        }
        else
        {
            u = x+fabs(eps1)*((d>0)?1.0:-1.0);
        }

        fu = (*f)(u);

        if(fu <= fx)                                     /* u比x要好*/
        {
            if(u<x)                                      /* 最优点u在a和c之间*/
            {
                c = x;
            }
            else
            {
                a = x;
            }

            v = w;                                       /* v是上一次的w*/
            w = x;                                       /* w是次优点*/
            x = u;                                       /* x是最优点*/
            fv = fw;
            fw = fx;
            fx = fu;
        }
        else                                             /* x比u好*/
        {
            if(u>=x)                                     /* 最优点x在a和c之间*/
            {
                c = u;
            }
            else
            {
                a = u;
            }

            if(fu <= fw||w==x)                           /* u是次优点，赋给w*/
            {
                v = w;
                w = u;
                fv = fw;
                fw = fu;
            }
            else if(fu<=fv||v==x||v==w)
            {
                v = u;
                fv = fu;
            }
        }
    }

    printf("exceed max iterations\n");                   /* 超过迭代次数*/
    *xopt = x;
    return(fx);
}
