#include <stdio.h>

#include "../utility.h"

/**
 * 函 数 名：cpdiv(a,n,b,m,q,r)
 * 功能描述：完成系数表示的复系数的多项式A与B相除
       商多项式系数放在q里，余式系数放在r里
 * 输入参数：a（多项式A系数），n（系数个数）
 *            b（多项式B系数），m（系数个数）
 *            q（商多项式Q系数），k（系数个数）k=max(n-m+1,0)
 *            r（余式R系数），l（系数个数）需要l=n
 * 返 回 值：整型数字。计算成功则返回1，否则返回0
 */
int cpdiv(struct c_comp *a,int n,struct c_comp *b,int m,struct c_comp *q,int k,struct c_comp *r,int l)
{
    int i,j,kk,jj;
    struct c_comp t1,t2;
    double tmp;

    if((a==NULL)||(b==NULL)||(q==NULL)||(r==NULL))  /* 检测指针是否为空*/
    {
        printf("(cpdiv)NULL pointer found.\n");
        return(0);
    }

    if(l!=n)
    {
        printf("(cpdiv)please set the length of r to n.\n");
        return(0);
    }

    for(i=0; i<n; i++)			          /* 先将a存入r中，这就是开始除法前的余式*/
    {
        r[i].rmz = a[i].rmz;
        r[i].imz = a[i].imz;
    }

    for(i=0; i<k; i++)				  /* 此时的商为0*/
    {
        q[i].rmz = 0;
        q[i].imz = 0;
    }

    /* 判断多项式B最高次项系数是否为0*/
    tmp = b[m-1].rmz*b[m-1].rmz+b[m-1].imz*b[m-1].imz;

    if(tmp+1.0==1.0)
    {
        printf("(cpdiv)Cannot divide zero");
        return(0);
    }

    b[m-1].imz = -b[m-1].imz;  			  /* 先取b[m-1]的共轭，将复数除法转化成乘法*/

    for(i=0; i<k; i++)
    {
        kk = k-i-1;
        jj = n-i-1;
        c_comp_product(&r[jj],&b[m-1],&t1);		  /* 求出当前的商*/
        q[kk].rmz = t1.rmz/tmp;
        q[kk].imz = t1.imz/tmp;
        r[jj].rmz = 0.0;			          /* 从余式中减去当前的商与多项式B的积*/
        r[jj].imz = 0.0;

        for(j=0; j<m-1; j++)
        {
            c_comp_product(&q[kk],&b[j],&t2);
            c_comp_sub(&r[j+kk], &t2, &r[j+kk]);
        }
    }

    b[m-1].imz = -b[m-1].imz; 			  /* 恢复b[m-1]*/
    return(1);
}

