#include "../utility.h"

/**
 * 函 数 名：rpmva(a,n,x,m,y)
 * 功能描述：利用多组求值方法求解一元多项式的值
 * 输入参数：a（多项式系数），n（多项式阶次）
 *            x（指定的值）,m（指定的值的个数）,y（返回的m个多项式值）
 * 返 回 值：若成功则返回1,否则返回0
 */
int rpmva(double *a,int n,double *x,int m,double *y)
{
    int i,j,k,nn,nk,kk,l,count,tail;
    double *ax,*b;
    double a1,t1,t2;
    k=log(n-0.5)/log(2.0)+1;	/* 求log2(k)*/
    nn=1;

    for(i=0; i<k; i++)
    {
        nn=nn<<1;
    }

    nk = nn>>1;
    a1 = a[n-1];		/* 检测首项系数是否为0，为0的话则返回。*/

    if(a1+1.0 == 1.0)
    {
        printf("(rpmva)coefficient too small,please check.\n");
        return 0;
    }

    /* b用来存放系数分解的中间结果，ax用来存放迭代计算的结果*/
    b = (double*)malloc(nn*sizeof(double));
    ax = (double*)malloc(nk*sizeof(double));

    for(i=0; i<n; i++)		/* 系数首1化*/
    {
        b[i] = a[i]/a1;
    }

    for(i=n; i<nn; i++)
    {
        b[i]=0.0;
    }

    l = nn>>1; 			/* l是每次分段的长度，count是分段的总个数的一半*/
    count = 1;

    for(i=1; i<k; i++)
    {
        /*  此是tail指向第一段的尾部，也就是多项式A1(x)的开头位置。
         *  注意多项式系数是从低阶向高阶依次存储的*/
        tail = l-1;

        for(j=0; j<count; j++)
        {
            b[tail]=b[tail]-1.0;  	/* 这个要减去1的值，就是我们算法说明里每次分解时的b*/

            for(kk=1; kk<l; kk++)   /* 使用这个循环完成了算法说明里的A0 = A0-b*A1*/
            {
                b[tail-kk] = b[tail-kk]-b[tail]*b[tail-kk+l];
            }

            tail = tail + 2*l;      /* tail指向下一个奇数段的尾部*/
        }

        l = l>>1;      		/* 每段的长度减半*/
        count = count<<1;         /* 分段的总数增加一倍*/
    }

    for(kk=0; kk<m; kk++)
    {
        t1 = x[kk];

        /* 第一次迭代，相加的结果存入ax中。
        * 这里完成了分解得到的一次多项式的运算*/
        for(i=0; i<nk; i++)
        {
            ax[i] = t1+b[2*i];
        }

        /* 以下的代码开始沿系数分解的逆顺序回推
        * 分解后的多项式两两成对，记为A0和A1*/
        tail = 1;        	       /* 则ax[j]指向的是A0的求值结果，ax[j+tail]指向的是A1的求值结果*/
        l = 2; 	       	       /* l的初始值是2*/
        t2 = t1;                 /* t2是就是待求值的x*/

        /* 合并k-1次，完成求值
        * 每次合并需要的b值从b中对应位置寻找
        * 每两段合并的结果都放在这两段最前面的位置
        * 这样最后的结果存放在ax[0]中*/
        for(i=1; i<k; i++)
        {
            t2=t2*t2;              /* 每次组合新一级的多项式对时，x都会变为原来的平方*/

            /* 将所有本级的多项式对进行组合*/
            for(j=0; j<nk; j=j+l)
            {
                ax[j] = ax[j]+ax[j+tail]*(t2+b[2*(j+tail)-1]);
            }

            tail = tail<<1;        /* 现在的多项式长度变为之前的两倍了*/
            l = l<<1;              /* 现在的多项式长度变为之前的两倍了*/
        }

        t2 = t2*t2/t1; 	       /* 消除b[nn-1]=1的影响*/

        if(nn!=n)
        {
            ax[0] -= t2;
        }

        y[kk]=ax[0]*a1;          /* 消除系数首1化带来的影响*/
    }

    free(b);
    free(ax);
    return 1;
}
